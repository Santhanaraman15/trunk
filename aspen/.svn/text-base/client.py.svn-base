from twisted.python import log, failure
from twisted.conch.telnet import TelnetProtocol
from twisted.internet.protocol import ReconnectingClientFactory, Factory
from twisted.internet.defer import succeed, fail
from twisted.internet import reactor
from collections import deque


from dsp import dsp

class aspen_protocol(TelnetProtocol):
    """

    """
    def connectionMade(self):
        log.msg( 'connection made: %s ' % (self.factory.name) )
        self.timeout_increment = 0.333
        self.send_list  = deque()

        self.aspen      = dsp(self.factory.name, self.timeout_increment)
        self.cycle_time = self.aspen.cycle['cycle_time']

        self._send_query_commands()
        self._set_timeout()



    def timeOut(self):
        log.msg( 'Aspen Timed Out %s ' % (self.factory.name) )
        self.transport.loseConnection()   

    def _send_query_commands(self):
        if len(self.send_list) > 0:
            log.msg( 'Send list was not complete before cycle called again' )
            reactor.callLater(self_timeout_increment/2, self._send_query_commands)
        else:
            #log.msg( ' cycle started: %s ' % (self.factory.name) )
            reactor.callLater(self.cycle_time, self._send_query_commands)
            for qry_cmd in self.aspen.cycle['commands']:
                self.send_list.append(qry_cmd['command'])
                reactor.callLater(qry_cmd['delay'], self._call_later)
        
    def _call_later(self):
        self.transport.write(self.send_list.popleft())

    def _set_timeout(self):
        t = self.cycle_time*6
        log.msg( 'setting aspen timout out for %s' % (t) )
        self.timeout = reactor.callLater(t, self.timeOut)

    def dataReceived(self, data):
        #log.msg( 'Aspen timer reset' )
        self.timeout.reset(self.aspen.timeout())

        d = self.aspen.put_in_cache(data)
        for listener in self.factory.listeners:
            d.addCallback( listener.transport.write )
     

        
    def connectionLost(self, reason):
        log.msg( 'connection lost: %s ' % (self.factory.name) )

class factory(ReconnectingClientFactory):
    """ 
    A class to manufacture connections to the Aspen units that will 
    reconnect if connection is lost. Note: Although this is a factory
    There should be only one connection to the client at a time.

    """
    initialDelay = 0.1   # reconnect delay (After connection is lost)
    maxDelay=120
    factor=2.71828

    protocol = aspen_protocol

    def __init__(self, name):
        self.listeners = []
        self.name = name
        self.noisy = False

    def startedConnecting(self, connector):
        log.msg('Attempting to connect to aspen: %s.' % (self.name))

    def buildProtocol(self, addr):
        self.resetDelay()   # Reset the delay
        self.p = Factory.buildProtocol(self, addr)
        return self.p

    def get_cached(self, data):
        if not self.p is None:
            d=self.p.aspen.get_from_cache(data)
        else:
            msg='no protocol instance for Aspen: %s. Device off?' % (self.name)
            d=fail(msg)
        if isinstance(d.result, failure.Failure):
            msg = d.result.getErrorMessage()
            if msg == 'no cache':
                d.addErrback( lambda r: self.p.transport.write(data) )
            else:
                d.addErrback( lambda r: log.msg(msg) )
        return d

    def clientConnectionLost(self, connector, reason):
        log.msg('Lost connection to aspen %s. Device off?' % (self.name))
        ReconnectingClientFactory.clientConnectionLost(self, 
                                                       connector, 
                                                       reason)
      
    def clientConnectionFailed(self, connector, reason):
        log.msg('Unable to connect to aspen %s. Device off?' % (self.name))
        ReconnectingClientFactory.clientConnectionFailed(self, 
                                                         connector,
                                                         reason)

